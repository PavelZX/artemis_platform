#!/usr/bin/env bash

# === Summary
#
# Ensures `.env` variables are loaded in all runtime environments.
#
# === Background
#
# The simplest way to set an environmental variable is to define it before
# calling a command:
#
#     $ VAR1=value VAR2=value ./example.sh
#
# Given the example above, the `example.sh` script will have access to $VAR1
# and $VAR2.
#
# This works for a single command, but what if we want to persist values between calls?
#
# To persist the values across calls, a common practice is to store all the
# variables in a single file and use the `source` command. Given a `.env` file:
#
#     VAR1=value
#     VAR2=value
#
# By using `source`, every subsequent call will also have access to the variables:
#
#     $ source .env
#     $ ./example.sh
#     $ ./other.sh
#
# This works well until one of the scripts spawns a subprocess. When that
# happens, the variables are not available to the subprocess (whether they were
# explicitly passed on the command-line or sourced from a file).
#
# One way to ensure a subprocesses also has access to the variables is to
# `export` the variable. The `.env` file could be updated to:
#
#     export VAR1=value
#     export VAR2=value
#
# Using the same `source` command will now make the variables available to all
# calls AND any subprocesses they spawn:
#
#     $ source .env
#     $ ./example.sh
#     $ ./other.sh
#
# Neat! Except there's one catch. Sometimes `export` in environmental files
# aren't supported like in the case of Docker and Docker Compose.
#
# Luckily, there's more than one way to export a variable value.
#
# If we go back to a standard `.env` file without an `export` statement:
#
#     VAR1=value
#     VAR2=value
#
# The `set -a` option can be used to automatically export any defined variables:
#
#     $ set -a
#     $ source .env
#     $ set +a
#     $ ./example.sh
#     $ ./other.sh
#
# That works! But it's a bit verbose. So to simplify the process, it can be
# captured in a script like this one:
#
#     $ bin/this_script.sh
#     $ ./example.sh
#     $ ./other.sh

ENV_FILE=.env
DOCKER_DIR=/app/config

# Check if in Docker environment by verifying if config directory exists
if [ -d "${DOCKER_DIR}" ]; then
  # Check if env file exists in docker config directory
  if [ ! -f "${DOCKER_DIR}/${ENV_FILE}" ]; then
    # Copy local .env file into docker config directory
    cp "${ENV_FILE}" "${DOCKER_DIR}/${ENV_FILE}"
  fi

  # Use the docker config file instead
  ENV_FILE="${DOCKER_DIR}/${ENV_FILE}"
fi

set -a
source "${ENV_FILE}"
set +a
